import * as yup from "yup";
import { appLevelOptions } from "../config";
import { deliverydetail_schema } from "./yup_deliverydetail";
import { SaOtherCharge, othercharge_schema } from "./yup_othercharge";
import {
	yupDateOptional,
	yupDateRequired,
	yupFinancialYearBound,
	yupIdOptional,
	yupIdRequired,
	yupNumberOptional,
	yupNumberOptionalMinMax,
	yupStringOptional,
	yupStringOptionalOneof,
	yupStringRequired,
} from "./yup_utils";

export const payment_againstinvoice_jt_schema = {
	cheque_amount: yupNumberOptionalMinMax(0),
	commission_amount: yupNumberOptionalMinMax(0),
	commission_calculate_on_base_number: yupNumberOptionalMinMax(0),
	commission_calculate_on_option: yupStringOptionalOneof(appLevelOptions.calculateCommissionOnOptions),
	commission_collect_from: yupStringOptionalOneof(appLevelOptions.commissionCollectFrom),
	commission_deducted_in_payment: yupNumberOptionalMinMax(0),
	commission_multiple: yupNumberOptionalMinMax(0),
	financial_year: yupFinancialYearBound(),
	// PK
	id: yupNumberOptionalMinMax(1), // autogenerated-serial
	// FK - CASCADE RESTRICT (STOP INVOICE DELETION)
	invoice_amount: yupNumberOptional,
	invoice_id: yupIdRequired,
	invoice_outstanding_amount: yup.number().required(),
	invoice_serialnumber: yup.number().required(),
	old_balance_amount: yup.number().required(),
	othercharges: yup
		.array()
		.transform((value, original) => {
			if (!original) return null;
			value = value.filter((chargeObj: SaOtherCharge) => Boolean(chargeObj.charge_type));
			return value.length === 0 ? null : value;
		})
		.optional()
		.nullable()
		.of(yup.object().shape(othercharge_schema).noUnknown()),
	payment_id: yupIdRequired,
	supplier_invoice_date: yupDateRequired,
	supplier_invoice_number: yupStringRequired, // on_account || invoice_supplier_invoice_number
	supplierid_finyr_invoicenumber: yupStringRequired, // <supplier_id>_<financial_year>_<supplier_invoice_number>
	total_drcr_amount: yupNumberOptional, // othercharges_amount - tds_amount - commission_amount
	total_gr_amount: yupNumberOptional,
	total_net_adjustment_amount: yup.number().required(), //cheque_amount + othercharges_amount
	total_othercharges_amount: yupNumberOptional,
	total_othertaxes_deducted: yupNumberOptionalMinMax(0),
	total_payment_amount: yupNumberOptionalMinMax(0), // cheque_amount + tds_amount + commission_amount
	total_tds_deducted: yupNumberOptionalMinMax(0),
	type: yupStringRequired.oneOf(["payment_against_invoice_jt"]).default("payment_against_invoice_jt"),
};

const pytAgtInvJt = yup.object(payment_againstinvoice_jt_schema).noUnknown();
export type SaPaymentAgainstInvoiceJt = yup.InferType<typeof pytAgtInvJt>;

export const payment_chequedetail_jt_schema = {
	cheque_amount: yupNumberOptionalMinMax(0),
	cheque_bankname: yupStringOptional,
	cheque_date: yupDateOptional,
	cheque_mode: yupStringOptional,
	cheque_number: yupStringOptional,
	financial_year: yup.number().required(),
	// PK
	id: yupNumberOptionalMinMax(1), // autogenerated-serial
	payment_id: yupIdOptional,
	commbill_id: yupIdOptional,
	payment_of_type: yup.string().oneOf(["payment"]).default("payment"),
	type: yupStringRequired.oneOf(["payment_cheque_detail_jt"]).default("payment_cheque_detail_jt"),
};
export interface SaPaymentChequeDetailJt {
	/** auto increment id */
	id: number;
	/** cheque amount */
	cheque_amount: number | null;
	/** cheque bankname */
	cheque_bankname: string | null;
	/** cheque date */
	cheque_date: string | null;
	/** cheque mode like pdc, rtgs, etc */
	cheque_mode: string | null;
	/** cheque number */
	cheque_number: string | null;
	/** payment_cheque_detail_jt */
	type: "payment_chequedetail_jt";
}

export const payment_drcrnote = {
	note_amount: yupNumberOptional,
	note_date: yupDateOptional,
	note_description: yupStringOptional,
	note_number: yupStringOptional,
	note_type: yupStringRequired.oneOf(["DEBIT NOTE", "CREDIT NOTE"]),
};

interface SaPaymentDrcrNote {
	/** note amount */
	note_amount: number | null;
	/** note date */
	note_date: string | null;
	/** note description */
	note_description: string | null;
	/** note number */
	note_number: string | null;
	/** note type */
	note_type: string;
}

export const payment_schema = {
	// against invoice details
	// CASCADE - DELETE
	againstinvoices: yup.array().required().min(1).of(yup.object().shape(payment_againstinvoice_jt_schema).noUnknown()),
	// customer details
	// FK
	customer_id: yup.number().required().min(1),
	customer_name: yupStringRequired,
	customer_branch: yupStringOptional,
	customer_subbroker_id: yup.number().min(1),
	customer_subbroker_name: yupStringRequired,
	customer_subbroker_incentive: yupNumberOptionalMinMax(0),
	// cheque details
	// CASCADE DELETE
	chequedetails: yup
		.array()
		.optional()
		.of(yup.object().shape(payment_chequedetail_jt_schema).noUnknown())
		.test("totalChequeAmt", "Cheque Amount Totals Not Matching", function (value) {
			const totalInvoiceChequeAmount = this.parent.againstinvoices.reduce((acc: any, curr: any) => acc + Number(curr.cheque_amount || 0), 0);
			if (value && value.length > 0) {
				const totalChequeAmt = value.reduce((acc, curr: any) => acc + Number(curr.cheque_amount || 0), 0);
				return totalChequeAmt === totalInvoiceChequeAmount;
			} else if((value && value.length <= 0) && totalInvoiceChequeAmount){
				return false
			}
			return true;
		}),
	// commission details
	commbill_id: yupIdOptional,
	commission_collect_from_option: yupStringOptionalOneof(["CUSTOMER", "SUPPLIER", "SUB-BROKER SUPPLIER", "SUB-BROKER CUSTOMER"]),
	commission_collect_from_id: yupNumberOptionalMinMax(1),
	commission_calculate_on_amount: yupNumberOptionalMinMax(0),
	commission_percentage_on_amount: yupNumberOptionalMinMax(0),
	commission_amount_on_amount: yupNumberOptionalMinMax(0),
	commission_amount_from_commissionbill: yupNumberOptionalMinMax(0),
	// debit note details
	drcrnotes: yup.array().optional().nullable().of(yup.object().shape(payment_drcrnote).noUnknown()),
	// GR delivery details
	// CASCADE DELETE
	grdeliverydetails: yup.array().nullable().optional().of(yup.object().shape(deliverydetail_schema).noUnknown()),
	// ownercompany details
	// FK
	ownercompany_id: yup.number().required().min(1),
	ownercompany_name: yup.string().required(),
	// salesman details
	// FK
	salesman_id: yup.number().required().min(1).typeError("Salesman is required"),
	salesman_name: yup.string().required(),
	salesman_incentive: yupNumberOptionalMinMax(0),
	// supplier details
	// FK
	supplier_id: yup.number().required().min(1),
	supplier_name: yupStringRequired,
	supplier_branch: yupStringOptional,
	supplier_subbroker_id: yup.number().required().min(1),
	supplier_subbroker_name: yupStringRequired,
	supplier_subbroker_incentive: yupNumberOptionalMinMax(0),
	// voucher details
	creation_date: yupStringOptional,
	extra_image_urls: yup.array().optional().nullable(),
	financial_year: yupFinancialYearBound(),
	grandtotal_cheque_amount: yupNumberOptionalMinMax(0)
		.test(
			"matchChequeDetailsTotal",
			"Grand total cheque amount must match sum of cheque details",
			function (value) {
				const chequeDetails = this.parent.chequedetails || [];
				const totalFromDetails = chequeDetails.reduce(
					(sum: number, detail: SaPaymentChequeDetailJt) => sum + Number(detail.cheque_amount || 0),
					0
				);
				return value === totalFromDetails;
			}
		),
	grandtotal_drcr_amount: yupNumberOptional, // othercharges_amount - tds_amount - commission_amount
	grandtotal_invoice_amount_in_payment: yup.number().min(0),
	grandtotal_net_adjustment_amount: yup
		.number()
		.required()
		.when("againstinvoices", ([againstinvoices], schema) => {
			const gt_adj_amt: number = againstinvoices.reduce(
				(acc: number, agtinv: SaPaymentAgainstInvoiceJt) => acc + (agtinv.total_net_adjustment_amount || 0),
				0,
			);
			return schema.min(gt_adj_amt).max(gt_adj_amt);
		}), //cheque_amount + othercharges_amount
	grandtotal_othercharges_amount: yupNumberOptional,
	grandtotal_payment_amount: yupNumberOptionalMinMax(0), // cheque_amount + tds_amount + commission_amount
	grandtotal_tds_amount: yupNumberOptionalMinMax(0),
	// PK
	id: yupIdRequired,
	notes: yupStringOptional,
	old_doc_id: yupStringOptional,
	serial_number: yup.number().required().min(1),
	status: yupStringRequired.oneOf(["Billed", "Draft", "Un-Billed"]).default("Un-Billed"),
	supplier_invoice_numbers: yup.array().required().of(yup.string().required()),
	invoice_ids: yup.array().required().of(yup.string().required()),
	type: yupStringRequired.default("payment").oneOf(["payment"]),
	updated_date: yupStringOptional,
	voucher_date: yupDateRequired,
};

export interface SaPayment {
	/** auto increment id */
	id: number;
	/** customer name */
	customer_name: string;
	/** customer branch */
	customer_branch: string | null;
	/** debit note details will be array of {note_amount: number, note_date: Date, note_description: string, note_number: string, note_type: string} */
	drcrnotes: SaPaymentDrcrNote | null;
	/** ownercompany name */
	ownercompany_name: string;
	/** supplier name */
	supplier_name: string;
	/** supplier branch */
	supplier_branch: string | null;
	/** grandtotal cheque amount */
	grandtotal_cheque_amount: number | null;
	/** grandtotal debit/credit amount, othercharges_amount - tds_amount - commission_amount */
	grandtotal_drcr_amount: number | null;
	/** grandtotal other charges amount */
	grandtotal_othercharges_amount: number | null;
	/** grandtotal payment amount, cheque_amount + tds_amount + commission_amount */
	grandtotal_payment_amount: number | null;
	/** grandtotal tds amount */
	grandtotal_tds_amount: number | null;
	/** extra image urls */
	extra_image_urls: string[] | null;
	/** note */
	note: string | null;
	/** serial number */
	serial_number: string;
	/** status should be one of ['Draft', 'Active'] */
	status: string;
	/** type should be payment */
	type: string;
	/** voucher date in YYYYMMDD format */
	voucher_date: string;
	/** auto increment id */
	customer_id: number | null;
	/** auto increment id */
	ownercompany_id: number | null;
	/** auto increment id */
	supplier_id: number | null;
}

export const paymentValidator = yup.object().shape(payment_schema).noUnknown();
