import * as yup from "yup";
import { appLevelOptions } from "../config";
import { address_schema } from "./yup_address";
import {
	yupDateOptional,
	yupDateRequired,
	yupFinancialYearBound,
	yupNumberOptional,
	yupNumberOptionalMinMax,
	yupStringOptional,
	yupStringOptionalOneof,
} from "./yup_utils";
import { SaVariationBreakdown, variationbreakdown_schema } from "./yup_variationbreakdown";

export const order_delivery_schema = {
	transport_id: yupNumberOptionalMinMax(1).typeError("Transport Id is required"),
	transport_name: yupStringOptional,
	transport_payment_mode: yupStringOptionalOneof(appLevelOptions.transportPaymentModes),
	transport_booking_branch: yupStringOptional,
};

export const order_product_jt_schema = {
	financial_year: yupFinancialYearBound(),
	id: yupNumberOptionalMinMax(1).typeError("product id is empty"), // serial - autogenerated
	order_id: yup.string().required(),
	product_id: yupNumberOptionalMinMax(1).typeError("product id is empty"),
	product_actual_quantity: yup.number().required().min(0.01),
	product_actual_uom: yup.string().required().oneOf(appLevelOptions.uomOptions),
	product_billed_price: yupNumberOptionalMinMax(0.01, 99999),
	product_billed_quantity: yup.number().required().min(0.01),
	product_billed_uom: yup.string().required().oneOf(appLevelOptions.uomOptions),
	product_name: yupStringOptional,
	product_brand_name: yupStringOptional,
	product_description: yupStringOptional,
	product_image_urls: yup.array().nullable().optional().of(yup.string().nullable()),
	product_taxable_amount: yupNumberOptionalMinMax(0.01),
	product_variations_breakdown: yup
		.array()
		.transform((v: SaVariationBreakdown[], o: SaVariationBreakdown[]) => {
			if (o && o.some((varObj) => varObj.variation_price || varObj.variation_quantity)) return v;
			return null;
		})
		.optional()
		.nullable()
		.of(yup.object().shape(variationbreakdown_schema).noUnknown()),
	product_minprice: yupNumberOptionalMinMax(0),
	product_maxprice: yupNumberOptionalMinMax(0),
	product_price_range_checkbox: yup.boolean().required().default(false),
	variation_type: yup.string().default("Size").typeError("Variation type should be entered")
};

const orderProdValidator = yup.object().shape(order_product_jt_schema).noUnknown();
type Order_Prod = yup.InferType<typeof orderProdValidator>;

export const order_schema = {
	// customer details
	// FK
	// customer: yup.object().shape(subbroker_schema).optional().nullable(),
	customer_id: yup.number().required().min(1).typeError("Customer is required"),
	customer_name: yup.string().required().typeError("Customer is required"),
	customer_branch: yupStringOptional,
	customer_po_number: yupStringOptional,
	// FK
	// customer_subbroker: yup.object().shape(subbroker_schema).optional().nullable(),
	customer_subbroker_id: yup.number().required().min(1).typeError("Customer Subbroker is required"),
	customer_subbroker_name: yup.string().required().typeError("Customer Subbroker is required"),
	// delivery details
	// CASCADE DELETE
	delivery_details: yup.array().nullable().optional().of(yup.object().shape(order_delivery_schema).noUnknown()),
	delivery_due_date: yupDateRequired,
	delivery_due_days: yup.number().required().typeError("Min delivery due days are required "),
	financial_year: yupFinancialYearBound(),
	shipping_address: yup
		.object()
		.optional()
		.shape({
			...address_schema,
			address_type: yupStringOptional.oneOf(["clientcompany"]),
		})
		.noUnknown(),
	// dispatch details
	grandtotal_dispatch_quantity: yupNumberOptionalMinMax(0),

	grandtotal_dispatch_uom: yupStringOptionalOneof([...appLevelOptions.uomOptions, "MANY"]).typeError(
		"Dispatch UOM should be one of PCS, KGS, MTR, MANY",
	),
	last_dispatch_date: yupDateOptional,
	order_close_reason: yupStringOptional,
	order_close_date: yupDateOptional,
	// ownercompany details
	// FK
	// ownercompany: yup.object().shape(ownercompany_schema).optional().nullable(),
	ownercompany_id: yup.number().required().min(1).typeError("Owner Company is required"),
	ownercompany_name: yup.string().required().typeError("Owner Company is required"),
	// products
	// CASCADE DELETE
	products: yup.array().of(yup.object().shape(order_product_jt_schema).noUnknown()).min(1),
	// salesman details
	// FK
	salesman_id: yup.number().required().min(1).typeError("Salesman is required"),
	salesman_name: yup.string().required().typeError("Salesman is required"),
	// supplier details
	// FK
	// supplier: yup.object().shape(client_companies_schema).optional().nullable(),
	supplier_id: yup.number().required().min(1).typeError("Supplier is required"),
	supplier_name: yup.string().required().typeError("Supplier is required"),
	supplier_branch: yupStringOptional,
	// FK
	supplier_subbroker_id: yup.number().required().min(1).typeError("Supplier Subbroker is required"),
	supplier_subbroker_name: yup.string().required().typeError("Supplier Subbroker is required"),
	// voucher details
	approx_price: yup
		.number()
		.when("products", ([products]: Order_Prod[][]) =>
			products?.every((prodObj: Order_Prod) => prodObj.product_taxable_amount)
				? yupNumberOptionalMinMax(0.01).typeError("Approx Price should be greater than 0")
				: yup.number().required().min(0.01),
		),
	extra_image_urls: yup.array().optional().nullable(),
	grandtotal_product_amount: yupNumberOptionalMinMax(0.01).typeError("Product Amt Should be above 0.01"),
	grandtotal_actual_quantity: yup.number().required().min(0.01).typeError("Actual Qty Should be above 0.01"),
	grandtotal_actual_uom: yup
		.string()
		.required()
		.oneOf([...appLevelOptions.uomOptions, "MANY"])
		.typeError("Actual UOM should be one of PCS, KGS, MTR, MANY"), // UOM = unit of masurement , If more than one uom, it will show many
	grandtotal_billed_quantity: yup.number().required().min(0.01).typeError("Billed Qty Should be above 0.01"),
	grandtotal_billed_uom: yup
		.string()
		.required()
		.oneOf([...appLevelOptions.uomOptions, "MANY"])
		.typeError("Billed UOM should be one of PCS, KGS, MTR, MANY"), // UOM = unit of masurement
	grandtotal_taxable_amount: yupNumberOptionalMinMax(0.01).typeError("Taxable Amt should be above 0.01"),
	grandtotal_order_amount: yup.number().required().min(0.01).typeError("Order Amt should be above 0.01"),
	gst_mode: yup.array().optional().nullable().of(yup.string()),
	// PK
	id: yup.string().required().typeError("id is required"), // <oc_id>_<order_number>
	notes: yupStringOptional,
	daily_order_number: yupNumberOptional,
	payment_terms: yupStringOptional,
	// take care this is nullable
	serial_number: yup.string().required().typeError("Entry Number is required"), // format 100A01 - (100 - Day of the year + 100 (1Apr = 100 & 1Jan = 375)) (A01 - serial number)
	status: yup
		.string()
		.required()
		.oneOf(["Draft", "Pending", "Part", "Excess", "Exact", "Closed"])
		.typeError("Status should be one of Draft,Pending,Part,Excess,Exact,Closed"),
	type: yup.string().required().default("order").oneOf(["order"]).typeError("Type should be Order"),
	voucher_date: yupDateRequired.typeError("Voucher Date is required"),
};

export const orderValidator = yup.object().shape(order_schema).noUnknown();
export type Order = yup.InferType<typeof orderValidator>;
